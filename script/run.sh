#!/usr/bin/env bash
#
# run.sh - Run gem5 experiments
#
# This script runs experiments in parallel.
# Uses the configuration file generated by create-conf.sh
#
# Usage:
#   ./script/run.sh                              # Run all experiments
#   ./script/run.sh parsec                       # Run only PARSEC suite
#   ./script/run.sh parsec blackscholes          # Run only blackscholes from PARSEC
#   ./script/run.sh parsec blackscholes MOESI_gem5  # Run specific protocol
#
# Output:
#   Results: {REPO_ROOT}/data/gem5.output/{suite}/{app}/{protocol}/
#   Logs:    {REPO_ROOT}/data/logs/{suite}_{app}_{protocol}.log
#
set -eo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
CONFIG_FILE="${REPO_ROOT}/benchmarks/configuration/commands.conf"
DATA_DIR="${REPO_ROOT}/data"
LOG_DIR="${DATA_DIR}/logs"

# Filters (optional)
FILTER_SUITE="${1:-}"
FILTER_APP="${2:-}"
FILTER_PROTOCOL="${3:-}"

# Check if config file exists
if [[ ! -f "${CONFIG_FILE}" ]]; then
    echo "ERROR: Configuration file not found: ${CONFIG_FILE}"
    echo "Run './script/create-conf.sh' first to generate it."
    exit 1
fi

# Check if required gem5 builds exist
REQUIRED_BUILDS=("MOESI_CMP_directory_edit" "MESI_unord" "MESI_unord_CXL")
MISSING_BUILDS=()
for protocol in "${REQUIRED_BUILDS[@]}"; do
    if [[ ! -f "${REPO_ROOT}/gem5/build/X86_${protocol}/gem5.opt" ]]; then
        MISSING_BUILDS+=("X86_${protocol}")
    fi
done

if [[ ${#MISSING_BUILDS[@]} -gt 0 ]]; then
    echo "ERROR: Missing gem5 builds: ${MISSING_BUILDS[*]}"
    echo "Run './script/build-gem5.sh' first to build gem5."
    exit 1
fi

# Create directories
mkdir -p "${LOG_DIR}"
mkdir -p "${LOG_DIR}/backup"

# PID file for tracking running processes
PID_FILE="${DATA_DIR}/running_pids.txt"
# Clear previous PID file
> "${PID_FILE}"

cd "${REPO_ROOT}"

echo "=============================================="
echo "Running gem5 experiments for C-3 experiments"
echo "=============================================="
echo "Config file: ${CONFIG_FILE}"
echo "Data directory: ${DATA_DIR}"
echo "Log directory: ${LOG_DIR}"
[[ -n "${FILTER_SUITE}" ]] && echo "Filter suite: ${FILTER_SUITE}"
[[ -n "${FILTER_APP}" ]] && echo "Filter app: ${FILTER_APP}"
[[ -n "${FILTER_PROTOCOL}" ]] && echo "Filter protocol: ${FILTER_PROTOCOL}"
echo "=============================================="
echo ""

#------------------------------------------------------------------------------
# Run a single experiment in background
#------------------------------------------------------------------------------
run_experiment() {
    local suite="$1"
    local csv_protocol="$2"
    local name="$3"
    local cmd_line="$4"
    local log_file="${LOG_DIR}/${suite}_${name}_${csv_protocol}.log"
    
    # Backup existing log if present
    if [[ -f "$log_file" ]]; then
        local timestamp=$(date +"%Y%m%d_%H%M%S")
        cp "$log_file" "${LOG_DIR}/backup/${suite}_${name}_${csv_protocol}_${timestamp}.log"
    fi
    
    # Run in background with output to log file
    {
        echo "[$(date)] STARTING: ${suite}/${name}/${csv_protocol}"
        local start_time=$(date +%s)
        
        cd "${REPO_ROOT}"
        if eval "${cmd_line}"; then
            local end_time=$(date +%s)
            local duration=$((end_time - start_time))
            echo "[$(date)] COMPLETED: ${suite}/${name}/${csv_protocol} in ${duration}s"
        else
            local exit_code=$?
            local end_time=$(date +%s)
            local duration=$((end_time - start_time))
            echo "[$(date)] FAILED: ${suite}/${name}/${csv_protocol} after ${duration}s (exit code: ${exit_code})"
        fi
    } > "${log_file}" 2>&1 &
    
    # Return PID directly (not via echo)
    LAST_PID=$!
}

#------------------------------------------------------------------------------
# Main execution
#------------------------------------------------------------------------------
declare -a running_pids=()
declare -A pid_info=()

current_suite=""
line_num=0
experiments_started=0

# Read config file line by line
while IFS= read -r line || [[ -n "$line" ]]; do
    line_num=$((line_num + 1))
    
    # Skip empty lines and comments
    [[ -z "$line" || "$line" =~ ^# ]] && continue
    
    # Check for section headers
    if [[ "$line" =~ ^\[([a-z]+)\] ]]; then
        current_suite="${BASH_REMATCH[1]}"
        continue
    fi
    
    # Parse command line
    # Format: suite | csv_protocol | name | command_line
    IFS='|' read -r suite csv_protocol name cmd_line <<< "$line"
    
    # Trim whitespace
    suite=$(echo "$suite" | xargs)
    csv_protocol=$(echo "$csv_protocol" | xargs)
    name=$(echo "$name" | xargs)
    cmd_line=$(echo "$cmd_line" | xargs)
    
    # Skip if not matching filters
    [[ -n "${FILTER_SUITE}" && "$suite" != "${FILTER_SUITE}" ]] && continue
    [[ -n "${FILTER_APP}" && "$name" != "${FILTER_APP}" && ! "$name" =~ ${FILTER_APP} ]] && continue
    [[ -n "${FILTER_PROTOCOL}" && "$csv_protocol" != "${FILTER_PROTOCOL}" ]] && continue
    
    # Check if output already exists (skip if stats.txt exists)
    out_dir=$(echo "$cmd_line" | grep -oP '(?<=--outdir=)[^ ]+')
    if [[ -f "${REPO_ROOT}/${out_dir}/stats.txt" ]]; then
        echo "SKIP: ${suite}/${name}/${csv_protocol} (stats.txt exists)"
        continue
    fi
    
    echo "QUEUE: ${suite}/${name}/${csv_protocol}"
    
    # Run experiment
    run_experiment "$suite" "$csv_protocol" "$name" "$cmd_line"
    running_pids+=("$LAST_PID")
    pid_info["$LAST_PID"]="${suite}/${name}/${csv_protocol}"
    echo "$LAST_PID ${suite}/${name}/${csv_protocol}" >> "${PID_FILE}"
    
    experiments_started=$((experiments_started + 1))
    
done < "${CONFIG_FILE}"

echo ""
echo "=============================================="
echo "Started ${experiments_started} experiments"
echo "=============================================="
echo ""

# Wait for all experiments to complete with progress monitoring
if [[ ${#running_pids[@]} -gt 0 ]]; then
    completed=0
    failed=0
    declare -A pid_done=()
    total=${#running_pids[@]}

    echo "Waiting for experiments to complete (progress every 30s)..."
    echo "You can monitor progress with: tail -f ${LOG_DIR}/*.log"
    echo ""

    while true; do
        still_running=0
        
        for pid in "${running_pids[@]}"; do
            if [[ "$pid" =~ ^[0-9]+$ && -z "${pid_done[$pid]:-}" ]]; then
                exp_name="${pid_info[$pid]}"
                
                # Check if process is still running
                if kill -0 "$pid" 2>/dev/null; then
                    ((still_running++)) || true
                else
                    # Process finished
                    pid_done[$pid]=1
                    if wait "$pid" 2>/dev/null; then
                        echo "[OK] ${exp_name}"
                        ((completed++)) || true
                    else
                        echo "[FAILED] ${exp_name}"
                        ((failed++)) || true
                    fi
                fi
            fi
        done
        
        # Exit loop when all done
        if [[ $still_running -eq 0 ]]; then
            break
        fi
        
        # Show progress
        echo ""
        echo "--- [$(date +%H:%M:%S)] Progress: ${completed} completed, ${failed} failed, ${still_running} running (of ${total}) ---"
        
        sleep 30
    done

    echo ""
    echo "=============================================="
    echo "Summary:"
    echo "  Total started: ${total}"
    echo "  Completed:     ${completed}"
    echo "  Failed:        ${failed}"
    echo "=============================================="
fi

# Summary
echo ""
echo "Results saved in: ${DATA_DIR}/gem5.output/"
echo "Logs saved in: ${LOG_DIR}/"
echo ""
echo "To monitor progress:"
echo "  1. View logs: tail -f ${LOG_DIR}/*.log"
echo "  2. Check process status: ps aux | grep gem5"
echo "  3. View log backups: ls -la ${LOG_DIR}/backup/"
echo ""
echo "Next step: Run './script/extract-stats.sh' to generate CSV files"
