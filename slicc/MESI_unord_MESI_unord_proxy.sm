//Backend.SLICC.ModularSLICC.proxy.GenProxyHeader
machine(MachineType:L0Cache, "Proxy cache controller")
: CacheMemory *cache;

  // The following latencies should be exposed as command-line parameters in a future update
  Cycles responseLatency := 1;
  Cycles recycleLatency := 10;

  // Dynamic networks
  MessageBuffer *fwdTo, network="To", virtual_network="0", vnet_type="fwd";
  MessageBuffer *fwdFrom, network="From", virtual_network="0", vnet_type="fwd";
  MessageBuffer *respTo, network="To", virtual_network="1", vnet_type="resp";
  MessageBuffer *respFrom, network="From", virtual_network="1", vnet_type="resp";
  MessageBuffer *reqTo, network="To", virtual_network="2", vnet_type="req";
  MessageBuffer *reqFrom, network="From", virtual_network="2", vnet_type="req";

{
  //Backend.SLICC.ModularSLICC.proxy.GenProxyStateDecl
  state_declaration(State, desc="L0Cache states", default="L0Cache_State_I__C__I") {
    E__C__M, AccessPermission:Maybe_Stale, desc="... TODO ...";
    Fwd_GetML2dM_x_pI_store_GetM_Ack_AD__C__M, AccessPermission:Busy, desc="... TODO ...";
    Fwd_GetML2dM_x_pI_store__C__M, AccessPermission:Busy, desc="... TODO ...";
    Fwd_GetSL2dM_x_pI_store_GetM_Ack_AD__C__M, AccessPermission:Busy, desc="... TODO ...";
    Fwd_GetSL2dM_x_pI_store__C__M, AccessPermission:Busy, desc="... TODO ...";
    GetML1I__C__I_store, AccessPermission:Invalid, desc="... TODO ...";
    GetML1I__C__I_store_GetM_Ack_AD, AccessPermission:Read_Only, desc="... TODO ...";
    GetML1I__C__S_store, AccessPermission:Read_Only, desc="... TODO ...";
    GetML1I__C__S_store_GetM_Ack_AD, AccessPermission:Read_Only, desc="... TODO ...";
    GetSL1E_GetS__C__M, AccessPermission:Busy, desc="... TODO ...";
    GetSL1I__C__I_store, AccessPermission:Invalid, desc="... TODO ...";
    GetSL1I__C__I_store_GetM_Ack_AD, AccessPermission:Read_Only, desc="... TODO ...";
    GetSL1I__C__S_store, AccessPermission:Read_Only, desc="... TODO ...";
    GetSL1I__C__S_store_GetM_Ack_AD, AccessPermission:Read_Only, desc="... TODO ...";
    GetSL1M_GetS__C__M, AccessPermission:Busy, desc="... TODO ...";
    I__C__I, AccessPermission:Invalid, desc="... TODO ...";
    I__C__M, AccessPermission:Read_Write, desc="... TODO ...";
    I__C__S, AccessPermission:Read_Only, desc="... TODO ...";
    M__C__M, AccessPermission:Maybe_Stale, desc="... TODO ...";
    S__C__M, AccessPermission:Read_Only, desc="... TODO ...";
    evictI__C__I_evict, AccessPermission:Busy, desc="... TODO ...";
    evictI__C__M_evict, AccessPermission:Busy, desc="... TODO ...";
    evictI__C__S_evict, AccessPermission:Busy, desc="... TODO ...";
    evictdM_x_pI_store_GetM_Ack_AD__C__M, AccessPermission:Busy, desc="... TODO ...";
    evictdM_x_pI_store__C__M, AccessPermission:Busy, desc="... TODO ...";

    S__C__S, AccessPermission:Read_Only, desc="... TODO ...";
    GetSL1I__C__I_load, AccessPermission:Invalid, desc="... TODO ...";
    InvL2dM_x_pI_store_GetM_Ack_AD__C__S, AccessPermission:Busy, desc="... TODO ...";
    evictdM_x_pI_store_GetM_Ack_AD__C__S, AccessPermission:Busy, desc="... TODO ...";

    GetML1S__C__I_store, AccessPermission:Busy, desc="... TODO ...";
    GetML1S__C__I_store_GetM_Ack_AD, AccessPermission:Busy, desc="... TODO ...";
    GetML1S__C__S_store, AccessPermission:Busy, desc="... TODO ...";
    GetML1S__C__S_store_GetM_Ack_AD, AccessPermission:Busy, desc="... TODO ...";
    InvL2dM_x_pI_store_GetM_Ack_AD__C__S_store, AccessPermission:Busy, desc="... TODO ...";
  }
  
  //Backend.SLICC.ModularSLICC.proxy.GenProxyEvents
  enumeration(Event, desc="Cache events") {
    deallocfwdfrom_in, desc="Event indicating the cache line + tbe should be deallocated following a message received on fwdfrom_in.";
    Stallfwdfrom_in, desc="Stall the fwdfrom_in port.";
    
    deallocreqfrom_in, desc="Event indicating the cache line + tbe should be deallocated following a message received on reqfrom_in.";
    Stallreqfrom_in, desc="Stall the reqfrom_in port.";
    
    deallocrespfrom_in, desc="Event indicating the cache line + tbe should be deallocated following a message received on respfrom_in.";
    Stallrespfrom_in, desc="Stall the respfrom_in port.";
    
    allocCacheEntry, desc="Allocate a new cache entry.";
    
    allocTBE, desc="Allocate a new TBE.";
    
    deallocTBE, desc="Deallocate a TBE.";
    deallocevict, desc="Deallocate Entry and copy to TBE while waiting for completion ACK.";
    
    Progress, desc="Progress, please!";
  }
  
  //Backend.SLICC.ModularSLICC.proxy.GenProxyStruct
  structure(Entry, desc="Stored variables of the Proxy machine", interface="AbstractCacheEntry") {
    State ProxyState, desc="Proxy state";
    DataBlock cl, desc="... TODO ...";
    NetDest cacheL1, desc="... TODO ...";
    MachineID ownerL1, desc="... TODO ...";
    MachineID proxy_msgL1_src, desc="... TODO ...";
    MachineID proxy_msgL2_src, desc="... TODO ...";
  }
  
  //Backend.SLICC.ModularSLICC.proxy.GenProxyTBE
  structure(TBE, desc="TBE entries for L0Cache machine") {
    State TBEState,       desc="Transient State";
    int acksReceivedL1, default=0, desc="...TODO...";
    int acksExpectedL1, default=0, desc="...TODO...";
    int acksReceivedL2, default=0, desc="...TODO...";
    int acksExpectedL2, default=0, desc="...TODO...";
    bool dirty, desc="Is the data dirty (different than memory)?";
    DataBlock cl, desc="... TODO ...";
  }
  
  structure(TBETable, external="yes"){
    TBE lookup(Addr);
    void allocate(Addr);
    void deallocate(Addr);
    bool isPresent(Addr);
    bool areNSlotsAvailable(int, Tick);
  }
  
  TBETable TBEs, template="<L0Cache_TBE>", constructor="m_number_of_TBEs";
  
  
  //Backend.SLICC.ModularSLICC.proxy.GenProxyStaticFns
  Tick clockEdge();
  Tick cyclesToTicks(Cycles c);
  Cycles ticksToCycles(Tick t);
  void set_cache_entry(AbstractCacheEntry a);
  void unset_cache_entry();
  void set_tbe(TBE a);
  void unset_tbe();
  void wakeUpAllBuffers(Addr a);
  
  MachineID mapAddressToMachine(Addr addr, MachineType mtype);
  
  Entry getEntry(Addr LineAddress), return_by_pointer="yes" {
    return static_cast(Entry, "pointer", cache.lookup(LineAddress));
  }

  DataBlock getCacheBlock(TBE tbe, Entry cache_entry, Addr LineAddress) {
    if (is_valid(tbe) && tbe.dirty) {
      return tbe.cl;
    } else if (is_valid(cache_entry)) {
      return cache_entry.cl;
    } else {
      error("Block not present!");
    }
  }

  void setCacheBlock(TBE tbe, Entry cache_entry, Addr LineAddress, DataBlock cl) {
    if (is_valid(tbe) && tbe.dirty) {
      tbe.cl := cl;
    } else if (is_valid(cache_entry)) {
      cache_entry.cl := cl;
    } else {
      error("Block not present!");
    }
  }
  
  State getState(TBE tbe, Entry cache_entry, Addr LineAddress) {
    if (is_valid(tbe)) {
      return tbe.TBEState;
    } else if (is_valid(cache_entry)) {
      return cache_entry.ProxyState;
    } else {
      return State:I__C__I;
    }
  }
  
  void setState(TBE tbe, Entry cache_entry, Addr LineAddress, State state) {
    DPRINTF(RubySlicc, "%s -> %s (addr: %#x)\n", getState(tbe, cache_entry, LineAddress), state, LineAddress);
    //if (state != getState(tbe, cache_entry, LineAddress)) {
      //  wakeUpAllBuffers(LineAddress);
      //}
      if (is_valid(tbe)) {
        tbe.TBEState := state;
      }
      if (is_valid(cache_entry)) {
        cache_entry.ProxyState := state;
      }
    }
    
    AccessPermission getAccessPermission(Addr LineAddress) {
      TBE tbe := TBEs[LineAddress];
      if (is_valid(tbe)) {
        return L0Cache_State_to_permission(tbe.TBEState);
      }
      Entry cache_entry := getEntry(LineAddress);
      if (is_valid(cache_entry)) {
        return L0Cache_State_to_permission(cache_entry.ProxyState);
      } else {
        return AccessPermission:NotPresent;
      }
    }
    
    void setAccessPermission(Entry cache_entry, Addr LineAddress, State state) {
      if (is_valid(cache_entry)) {
        cache_entry.changePermission(L0Cache_State_to_permission(state));
      }
    }
    
    void functionalRead(Addr addr, Packet *pkt) {
      TBE tbe := TBEs[addr];
      Entry cache_entry := getEntry(addr);
      if (is_valid(cache_entry)) {
        testAndRead(addr, cache_entry.cl, pkt);
      } else if(is_valid(tbe) && tbe.dirty) {
        testAndRead(addr, tbe.cl, pkt);
      } else {
        error("Block not present!");
      }
    }
    
    int functionalWrite(Addr addr, Packet *pkt) {
      int num_functional_writes := 0;

      Entry cache_entry := getEntry(addr);
      if (is_valid(cache_entry)) {
        num_functional_writes := num_functional_writes +
          testAndWrite(addr, cache_entry.cl, pkt);
        return num_functional_writes;
      }

      TBE tbe := TBEs[addr];
      if(is_valid(tbe) && tbe.dirty) {
        num_functional_writes := num_functional_writes +
        testAndWrite(addr, tbe.cl, pkt);
      }
      return num_functional_writes;
    }
    
    //Backend.SLICC.ModularSLICC.proxy.GenProxyOutPorts
    out_port(fwdto_out, CoherenceMessage, fwdTo);
    out_port(reqto_out, CoherenceMessage, reqTo);
    out_port(respto_out, CoherenceMessage, respTo);
    
    //Backend.SLICC.ModularSLICC.proxy.GenProxyInPorts
    in_port(fwdfrom_in, CoherenceMessage, fwdFrom, rank=1) {
      if (fwdfrom_in.isReady(clockEdge())) {
        peek (fwdfrom_in, CoherenceMessage, block_on="LineAddress") {
          Addr LineAddress := in_msg.LineAddress;
          TBE tbe := TBEs[LineAddress];
          State st := getState(tbe, getEntry(LineAddress), LineAddress);
          DPRINTF(RubySlicc, "fwdfrom_in: %s %s %s (addr: %#x)\n", in_msg.Type, in_msg.Sender, st, LineAddress);
          if (st == State:E__C__M) {
            if (in_msg.Type == CoherenceMessageType:Fwd_GetML2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on fwdfrom_in (addr: %#x)\n", st, LineAddress);
                  fwdfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                out_msg.Sender := machineID;
              }
              getEntry(LineAddress).ownerL1 := machineID;
              getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
              setState(tbe, getEntry(LineAddress), LineAddress, State:Fwd_GetML2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              fwdfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:Fwd_GetSL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on fwdfrom_in (addr: %#x)\n", st, LineAddress);
                  fwdfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                out_msg.Sender := machineID;
              }
              getEntry(LineAddress).ownerL1 := machineID;
              getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
              setState(tbe, getEntry(LineAddress), LineAddress, State:Fwd_GetSL2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              fwdfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:S__C__S) {
            if (in_msg.Type == CoherenceMessageType:InvL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on fwdfrom_in (addr: %#x)\n", st, LineAddress);
                  fwdfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              if (getEntry(LineAddress).cacheL1.isElement(machineID)) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  getEntry(LineAddress).cacheL1.clear();
                  if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    setState(tbe, getEntry(LineAddress), LineAddress, State:InvL2dM_x_pI_store_GetM_Ack_AD__C__S);
                    DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    fwdfrom_in.dequeue(clockEdge());
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  } else if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                    if (getEntry(LineAddress).ownerL1 == machineID) {
                      getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                      enqueue(respto_out, CoherenceMessage, responseLatency) {
                        out_msg.LineAddress := LineAddress;
                        out_msg.MessageSize := MessageSizeType:Control;
                        out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                        out_msg.Type := CoherenceMessageType:Inv_AckL2;
                        out_msg.Sender := machineID;
                        //out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                      }
                      setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                      trigger(Event:deallocfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
                    }
                  }
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(machineID) == false) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                getEntry(LineAddress).cacheL1.clear();
                if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:InvL2dM_x_pI_store_GetM_Ack_AD__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  fwdfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  if (getEntry(LineAddress).ownerL1 == machineID) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    enqueue(respto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                      out_msg.Type := CoherenceMessageType:Inv_AckL2;
                      out_msg.Sender := machineID;
                      //out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                    trigger(Event:deallocfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1I__C__S_store) {
            if (in_msg.Type == CoherenceMessageType:InvL2) {
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).ownerL1 := machineID;
              tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (getEntry(LineAddress).ownerL1 == machineID) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:Inv_AckL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__I_store);
                  DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  fwdfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1I__C__S_store) {
            if (in_msg.Type == CoherenceMessageType:InvL2) {
              tbe.acksReceivedL1 := 0;
              getEntry(LineAddress).ownerL1 := machineID;
              tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (getEntry(LineAddress).ownerL1 == machineID) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:Inv_AckL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__I_store);
                  DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  fwdfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1S__C__S_store) {
            if (in_msg.Type == CoherenceMessageType:InvL2) {
              tbe.acksReceivedL1 := 0;
              if (getEntry(LineAddress).cacheL1.isElement(machineID)) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  getEntry(LineAddress).cacheL1.clear();
                  if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                    if (getEntry(LineAddress).ownerL1 == machineID) {
                      getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                      enqueue(respto_out, CoherenceMessage, responseLatency) {
                        out_msg.LineAddress := LineAddress;
                        out_msg.MessageSize := MessageSizeType:Data;
                        out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                        out_msg.Type := CoherenceMessageType:Inv_AckL2;
                        out_msg.Sender := machineID;
                        out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                      }
                      setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__I_store);
                      DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                      fwdfrom_in.dequeue(clockEdge());
                      trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                    }
                  }
                  else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    setState(tbe, getEntry(LineAddress), LineAddress, State:InvL2dM_x_pI_store_GetM_Ack_AD__C__S_store);
                    DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    fwdfrom_in.dequeue(clockEdge());
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(machineID) == false) {
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                getEntry(LineAddress).cacheL1.clear();
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  if (getEntry(LineAddress).ownerL1 == machineID) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    enqueue(respto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Data;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                      out_msg.Type := CoherenceMessageType:Inv_AckL2;
                      out_msg.Sender := machineID;
                      out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__I_store);
                    DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    fwdfrom_in.dequeue(clockEdge());
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  setState(tbe, getEntry(LineAddress), LineAddress, State:InvL2dM_x_pI_store_GetM_Ack_AD__C__S_store);
                  DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  fwdfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:I__C__M) {
            if (in_msg.Type == CoherenceMessageType:Fwd_GetML2) {
              getEntry(LineAddress).ownerL1 := machineID;
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (getEntry(LineAddress).ownerL1 == machineID) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:GetM_Ack_DL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
            } else if (in_msg.Type == CoherenceMessageType:Fwd_GetSL2) {
              getEntry(LineAddress).ownerL1 := machineID;
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (getEntry(LineAddress).ownerL1 == machineID) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:GetS_AckL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                    out_msg.Type := CoherenceMessageType:WBL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  fwdfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:I__C__S) {
            if (in_msg.Type == CoherenceMessageType:InvL2) {
              getEntry(LineAddress).ownerL1 := machineID;
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (getEntry(LineAddress).ownerL1 == machineID) {
                  getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:Inv_AckL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:M__C__M) {
            if (in_msg.Type == CoherenceMessageType:Fwd_GetML2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on fwdfrom_in (addr: %#x)\n", st, LineAddress);
                  fwdfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                out_msg.Sender := machineID;
              }
              getEntry(LineAddress).ownerL1 := machineID;
              getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
              setState(tbe, getEntry(LineAddress), LineAddress, State:Fwd_GetML2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              fwdfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:Fwd_GetSL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on fwdfrom_in (addr: %#x)\n", st, LineAddress);
                  fwdfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                out_msg.Sender := machineID;
              }
              getEntry(LineAddress).ownerL1 := machineID;
              getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
              setState(tbe, getEntry(LineAddress), LineAddress, State:Fwd_GetSL2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              fwdfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:S__C__M) {
            if (in_msg.Type == CoherenceMessageType:Fwd_GetML2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on fwdfrom_in (addr: %#x)\n", st, LineAddress);
                  fwdfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              if (getEntry(LineAddress).cacheL1.isElement(machineID)) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  getEntry(LineAddress).cacheL1.clear();
                  if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    setState(tbe, getEntry(LineAddress), LineAddress, State:Fwd_GetML2dM_x_pI_store_GetM_Ack_AD__C__M);
                    DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    fwdfrom_in.dequeue(clockEdge());
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  } else
                  if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                    getEntry(LineAddress).cacheL1.remove(machineID);
                    if (getEntry(LineAddress).ownerL1 == machineID) {
                      getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                      enqueue(respto_out, CoherenceMessage, responseLatency) {
                        out_msg.LineAddress := LineAddress;
                        out_msg.MessageSize := MessageSizeType:Data;
                        out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                        out_msg.Type := CoherenceMessageType:GetM_Ack_DL2;
                        out_msg.Sender := machineID;
                        out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                      }
                      setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                      trigger(Event:deallocfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
                    }
                  }
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(machineID) == false) {
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  getEntry(LineAddress).cacheL1.clear();
                  if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    setState(tbe, getEntry(LineAddress), LineAddress, State:Fwd_GetML2dM_x_pI_store_GetM_Ack_AD__C__M);
                    DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    fwdfrom_in.dequeue(clockEdge());
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  } else
                  if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                    getEntry(LineAddress).cacheL1.remove(machineID);
                    if (getEntry(LineAddress).ownerL1 == machineID) {
                      getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                      enqueue(respto_out, CoherenceMessage, responseLatency) {
                        out_msg.LineAddress := LineAddress;
                        out_msg.MessageSize := MessageSizeType:Data;
                        out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                        out_msg.Type := CoherenceMessageType:GetM_Ack_DL2;
                        out_msg.Sender := machineID;
                        out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                      }
                      setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                      trigger(Event:deallocfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
                    }
                  }
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:Fwd_GetSL2) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on fwdfrom_in (addr: %#x)\n", st, LineAddress);
                  fwdfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              tbe.acksReceivedL1 := 0;
              if (getEntry(LineAddress).cacheL1.isElement(machineID)) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  getEntry(LineAddress).cacheL1.clear();
                  if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    setState(tbe, getEntry(LineAddress), LineAddress, State:Fwd_GetSL2dM_x_pI_store_GetM_Ack_AD__C__M);
                    DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    fwdfrom_in.dequeue(clockEdge());
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  } else
                  if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                    getEntry(LineAddress).cacheL1.remove(machineID);
                    if (getEntry(LineAddress).ownerL1 == machineID) {
                      getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                      enqueue(respto_out, CoherenceMessage, responseLatency) {
                        out_msg.LineAddress := LineAddress;
                        out_msg.MessageSize := MessageSizeType:Data;
                        out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                        out_msg.Type := CoherenceMessageType:GetS_AckL2;
                        out_msg.Sender := machineID;
                        out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                      }
                      enqueue(respto_out, CoherenceMessage, responseLatency) {
                        out_msg.LineAddress := LineAddress;
                        out_msg.MessageSize := MessageSizeType:Data;
                        out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                        out_msg.Type := CoherenceMessageType:WBL2;
                        out_msg.Sender := machineID;
                        out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                      }
                      setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                      DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                      fwdfrom_in.dequeue(clockEdge());
                      trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                    }
                  }
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(machineID) == false) {
                if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  getEntry(LineAddress).cacheL1.clear();
                  if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                    getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                    setState(tbe, getEntry(LineAddress), LineAddress, State:Fwd_GetSL2dM_x_pI_store_GetM_Ack_AD__C__M);
                    DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    fwdfrom_in.dequeue(clockEdge());
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  } else
                  if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                    getEntry(LineAddress).cacheL1.remove(machineID);
                    if (getEntry(LineAddress).ownerL1 == machineID) {
                      getEntry(LineAddress).proxy_msgL2_src := in_msg.Sender;
                      enqueue(respto_out, CoherenceMessage, responseLatency) {
                        out_msg.LineAddress := LineAddress;
                        out_msg.MessageSize := MessageSizeType:Data;
                        out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                        out_msg.Type := CoherenceMessageType:GetS_AckL2;
                        out_msg.Sender := machineID;
                        out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                      }
                      enqueue(respto_out, CoherenceMessage, responseLatency) {
                        out_msg.LineAddress := LineAddress;
                        out_msg.MessageSize := MessageSizeType:Data;
                        out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                        out_msg.Type := CoherenceMessageType:WBL2;
                        out_msg.Sender := machineID;
                        out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                      }
                      setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                      DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                      fwdfrom_in.dequeue(clockEdge());
                      trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                    }
                  }
                }
              }
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictI__C__M_evict) {
            if (in_msg.Type == CoherenceMessageType:Fwd_GetML2) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:GetM_Ack_DL2;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__I_evict);
              DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              fwdfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:Fwd_GetSL2) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:GetS_AckL2;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                out_msg.Type := CoherenceMessageType:WBL2;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__S_evict);
              DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              fwdfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictI__C__S_evict) {
            if (in_msg.Type == CoherenceMessageType:InvL2) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:Inv_AckL2;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__I_evict);
              DPRINTF(RubySlicc, "Popping %s %s on fwdfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              fwdfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else {
            trigger(Event:Stallfwdfrom_in, LineAddress, getEntry(LineAddress), tbe);
          }
        }
      }
    }
    
    in_port(respfrom_in, CoherenceMessage, respFrom, rank=0) {
      if (respfrom_in.isReady(clockEdge())) {
        peek (respfrom_in, CoherenceMessage, block_on="LineAddress") {
          Addr LineAddress := in_msg.LineAddress;
          TBE tbe := TBEs[LineAddress];
          State st := getState(tbe, getEntry(LineAddress), LineAddress);
          DPRINTF(RubySlicc, "respfrom_in: %s %s %s (addr: %#x)\n", in_msg.Type, in_msg.Sender, st, LineAddress);
          if (st == State:Fwd_GetML2dM_x_pI_store_GetM_Ack_AD__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (getEntry(LineAddress).ownerL1 == machineID) {
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:GetM_Ack_DL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:Fwd_GetML2dM_x_pI_store_GetM_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:InvL2dM_x_pI_store_GetM_Ack_AD__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                if (getEntry(LineAddress).ownerL1 == machineID) {
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:Inv_AckL2;
                    out_msg.Sender := machineID;
                    //out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                  trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:InvL2dM_x_pI_store_GetM_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:Fwd_GetML2dM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (getEntry(LineAddress).ownerL1 == machineID) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:GetM_Ack_DL2;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:Fwd_GetML2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:Fwd_GetSL2dM_x_pI_store_GetM_Ack_AD__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (getEntry(LineAddress).ownerL1 == machineID) {
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:GetS_AckL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                    out_msg.Type := CoherenceMessageType:WBL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:Fwd_GetSL2dM_x_pI_store_GetM_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:Fwd_GetSL2dM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (getEntry(LineAddress).ownerL1 == machineID) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                  out_msg.Type := CoherenceMessageType:GetS_AckL2;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                  out_msg.Type := CoherenceMessageType:WBL2;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:Fwd_GetSL2dM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1I__C__I_store) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_ADL2) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL2 := in_msg.acksExpectedL2;
              if (tbe.acksExpectedL2 == tbe.acksReceivedL2) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL2 != tbe.acksReceivedL2) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__I_store_GetM_Ack_AD);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL2) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
              }
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL2) {
              tbe.acksReceivedL2 := tbe.acksReceivedL2+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__I_store);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1I__C__I_store_GetM_Ack_AD) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL2) {
              tbe.acksReceivedL2 := tbe.acksReceivedL2+1;
              if (tbe.acksExpectedL2 == tbe.acksReceivedL2) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL2 != tbe.acksReceivedL2) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__I_store_GetM_Ack_AD);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1I__C__S_store) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_ADL2) {
              tbe.acksExpectedL2 := in_msg.acksExpectedL2;
              if (tbe.acksExpectedL2 == tbe.acksReceivedL2) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL2 != tbe.acksReceivedL2) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__S_store_GetM_Ack_AD);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL2) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
              }
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL2) {
              tbe.acksReceivedL2 := tbe.acksReceivedL2+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__S_store);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1I__C__S_store_GetM_Ack_AD) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL2) {
              tbe.acksReceivedL2 := tbe.acksReceivedL2+1;
              if (tbe.acksExpectedL2 == tbe.acksReceivedL2) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL2 != tbe.acksReceivedL2) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__S_store_GetM_Ack_AD);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1E_GetS__C__M) {
            if (in_msg.Type == CoherenceMessageType:WBL1) {
              if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1E_GetS__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1I__C__I_load) {
            if (in_msg.Type == CoherenceMessageType:GetS_AckL2) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetS_AckL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
              setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1I__C__I_store) {
            if (in_msg.Type == CoherenceMessageType:GetS_AckL2) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetS_AckL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
              setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetM_Ack_ADL2) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL2 := in_msg.acksExpectedL2;
              if (tbe.acksExpectedL2 == tbe.acksReceivedL2) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL2 != tbe.acksReceivedL2) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__I_store_GetM_Ack_AD);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL2) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL2) {
              tbe.acksReceivedL2 := tbe.acksReceivedL2+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__I_store);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1I__C__I_store_GetM_Ack_AD) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL2) {
              tbe.acksReceivedL2 := tbe.acksReceivedL2+1;
              if (tbe.acksExpectedL2 == tbe.acksReceivedL2) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL2 != tbe.acksReceivedL2) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__I_store_GetM_Ack_AD);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1I__C__S_store) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_ADL2) {
              tbe.acksExpectedL2 := in_msg.acksExpectedL2;
              if (tbe.acksExpectedL2 == tbe.acksReceivedL2) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL2 != tbe.acksReceivedL2) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__S_store_GetM_Ack_AD);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL2) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL2) {
              tbe.acksReceivedL2 := tbe.acksReceivedL2+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__S_store);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1I__C__S_store_GetM_Ack_AD) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL2) {
              tbe.acksReceivedL2 := tbe.acksReceivedL2+1;
              if (tbe.acksExpectedL2 == tbe.acksReceivedL2) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (tbe.acksExpectedL2 != tbe.acksReceivedL2) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__S_store_GetM_Ack_AD);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetSL1M_GetS__C__M) {
            if (in_msg.Type == CoherenceMessageType:WBL1) {
              if (in_msg.Sender == getEntry(LineAddress).ownerL1) {
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (in_msg.Sender != getEntry(LineAddress).ownerL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1M_GetS__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictI__C__I_evict) {
            if (in_msg.Type == CoherenceMessageType:PutI_AckL2) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              tbe.dirty := false; 
              respfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              //trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictI__C__M_evict) {
            if (in_msg.Type == CoherenceMessageType:PutM_AckL2) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              tbe.dirty := false; 
              respfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              //trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictI__C__S_evict) {
            if (in_msg.Type == CoherenceMessageType:PutS_AckL2) {
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              tbe.dirty := false; 
              respfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              //trigger(Event:deallocrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdM_x_pI_store_GetM_Ack_AD__C__M) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                getEntry(LineAddress).cacheL1.remove(machineID);
                if (getEntry(LineAddress).ownerL1 == machineID) {
                  enqueue(reqto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                    out_msg.Type := CoherenceMessageType:PutML2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__M_evict);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                  //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetM_Ack_AD__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdM_x_pI_store_GetM_Ack_AD__C__S) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                if (getEntry(LineAddress).ownerL1 == machineID) {
                  enqueue(reqto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                    out_msg.Type := CoherenceMessageType:PutSL2;
                    out_msg.Sender := machineID;
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__S_evict);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                  //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetM_Ack_AD__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1S__C__S_store) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_ADL2) {
              tbe.acksExpectedL2 := in_msg.acksExpectedL2;
              if (tbe.acksExpectedL2 == tbe.acksReceivedL2) {
                if (getEntry(LineAddress).cacheL1.isElement(getEntry(LineAddress).proxy_msgL1_src)) {
                  getEntry(LineAddress).cacheL1.remove(getEntry(LineAddress).proxy_msgL1_src);
                  if (getEntry(LineAddress).cacheL1.count() == 0) {
                    enqueue(respto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Data;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                      out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                      out_msg.Sender := machineID;
                      out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    }
                    getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                    getEntry(LineAddress).cacheL1.clear();
                    setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                    DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    respfrom_in.dequeue(clockEdge());
                    trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  }
                  else if (getEntry(LineAddress).cacheL1.count() != 0) {
                    enqueue(respto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Data;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                      out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                      out_msg.Sender := machineID;
                      out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                      out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                    }
                    enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination := getEntry(LineAddress).cacheL1;
                      out_msg.Type := CoherenceMessageType:InvL1;
                      out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                    }
                    getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                    getEntry(LineAddress).cacheL1.clear();
                    setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                    DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    respfrom_in.dequeue(clockEdge());
                    trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                else if (getEntry(LineAddress).cacheL1.isElement(getEntry(LineAddress).proxy_msgL1_src) == false) {
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                    out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  }
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL2 != tbe.acksReceivedL2) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__S_store_GetM_Ack_AD);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL2) {
              if (getEntry(LineAddress).cacheL1.isElement(getEntry(LineAddress).proxy_msgL1_src)) {
                getEntry(LineAddress).cacheL1.remove(getEntry(LineAddress).proxy_msgL1_src);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                    out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                    out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  }
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(getEntry(LineAddress).proxy_msgL1_src) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                }
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                getEntry(LineAddress).cacheL1.clear();
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL2) {
              tbe.acksReceivedL2 := tbe.acksReceivedL2+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__S_store);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1S__C__S_store_GetM_Ack_AD) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL2) {
              tbe.acksReceivedL2 := tbe.acksReceivedL2+1;
              if (tbe.acksExpectedL2 == tbe.acksReceivedL2) {
                if (getEntry(LineAddress).cacheL1.isElement(getEntry(LineAddress).proxy_msgL1_src)) {
                  getEntry(LineAddress).cacheL1.remove(getEntry(LineAddress).proxy_msgL1_src);
                  if (getEntry(LineAddress).cacheL1.count() == 0) {
                    enqueue(respto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Data;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                      out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                      out_msg.Sender := machineID;
                      out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    }
                    getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                    getEntry(LineAddress).cacheL1.clear();
                    setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                    DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    respfrom_in.dequeue(clockEdge());
                    trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  }
                  else if (getEntry(LineAddress).cacheL1.count() != 0) {
                    enqueue(respto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Data;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                      out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                      out_msg.Sender := machineID;
                      out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                      out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                    }
                    enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination := getEntry(LineAddress).cacheL1;
                      out_msg.Type := CoherenceMessageType:InvL1;
                      out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                    }
                    getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                    getEntry(LineAddress).cacheL1.clear();
                    setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                    DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    respfrom_in.dequeue(clockEdge());
                    trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                else if (getEntry(LineAddress).cacheL1.isElement(getEntry(LineAddress).proxy_msgL1_src) == false) {
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                    out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  }
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL2 != tbe.acksReceivedL2) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__S_store_GetM_Ack_AD);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:InvL2dM_x_pI_store_GetM_Ack_AD__C__S_store) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                if (getEntry(LineAddress).ownerL1 == machineID) {
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL2_src);
                    out_msg.Type := CoherenceMessageType:Inv_AckL2;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__I_store);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:InvL2dM_x_pI_store_GetM_Ack_AD__C__S_store);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1S__C__I_store) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_ADL2) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              tbe.acksExpectedL2 := in_msg.acksExpectedL2;
              if (tbe.acksExpectedL2 == tbe.acksReceivedL2) {
                if (getEntry(LineAddress).cacheL1.isElement(getEntry(LineAddress).proxy_msgL1_src)) {
                  getEntry(LineAddress).cacheL1.remove(getEntry(LineAddress).proxy_msgL1_src);
                  if (getEntry(LineAddress).cacheL1.count() == 0) {
                    enqueue(respto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Data;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                      out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                      out_msg.Sender := machineID;
                      out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    }
                    getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                    getEntry(LineAddress).cacheL1.clear();
                    setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                    DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    respfrom_in.dequeue(clockEdge());
                    trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  }
                  else if (getEntry(LineAddress).cacheL1.count() != 0) {
                    enqueue(respto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Data;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                      out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                      out_msg.Sender := machineID;
                      out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                      out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                    }
                    enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination := getEntry(LineAddress).cacheL1;
                      out_msg.Type := CoherenceMessageType:InvL1;
                      out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                    }
                    getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                    getEntry(LineAddress).cacheL1.clear();
                    setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                    DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    respfrom_in.dequeue(clockEdge());
                    trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                else if (getEntry(LineAddress).cacheL1.isElement(getEntry(LineAddress).proxy_msgL1_src) == false) {
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                    out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  }
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL2 != tbe.acksReceivedL2) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__I_store_GetM_Ack_AD);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL2) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              if (getEntry(LineAddress).cacheL1.isElement(getEntry(LineAddress).proxy_msgL1_src)) {
                getEntry(LineAddress).cacheL1.remove(getEntry(LineAddress).proxy_msgL1_src);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                    out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                    out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  }
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(getEntry(LineAddress).proxy_msgL1_src) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                  out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                }
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1;
                  out_msg.Type := CoherenceMessageType:InvL1;
                  out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                }
                getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                getEntry(LineAddress).cacheL1.clear();
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL2) {
              tbe.acksReceivedL2 := tbe.acksReceivedL2+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__I_store);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:GetML1S__C__I_store_GetM_Ack_AD) {
            if (in_msg.Type == CoherenceMessageType:Inv_AckL2) {
              tbe.acksReceivedL2 := tbe.acksReceivedL2+1;
              if (tbe.acksExpectedL2 == tbe.acksReceivedL2) {
                if (getEntry(LineAddress).cacheL1.isElement(getEntry(LineAddress).proxy_msgL1_src)) {
                  getEntry(LineAddress).cacheL1.remove(getEntry(LineAddress).proxy_msgL1_src);
                  if (getEntry(LineAddress).cacheL1.count() == 0) {
                    enqueue(respto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Data;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                      out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                      out_msg.Sender := machineID;
                      out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    }
                    getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                    getEntry(LineAddress).cacheL1.clear();
                    setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                    DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    respfrom_in.dequeue(clockEdge());
                    trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  }
                  else if (getEntry(LineAddress).cacheL1.count() != 0) {
                    enqueue(respto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Data;
                      out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                      out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                      out_msg.Sender := machineID;
                      out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                      out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                    }
                    enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination := getEntry(LineAddress).cacheL1;
                      out_msg.Type := CoherenceMessageType:InvL1;
                      out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                    }
                    getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                    getEntry(LineAddress).cacheL1.clear();
                    setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                    DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                    respfrom_in.dequeue(clockEdge());
                    trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                else if (getEntry(LineAddress).cacheL1.isElement(getEntry(LineAddress).proxy_msgL1_src) == false) {
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                    out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  }
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  respfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (tbe.acksExpectedL2 != tbe.acksReceivedL2) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__I_store_GetM_Ack_AD);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:evictdM_x_pI_store__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1) {
              setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
              getEntry(LineAddress).cacheL1.remove(machineID);
              if (getEntry(LineAddress).ownerL1 == machineID) {
                enqueue(reqto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Data;
                  out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                  out_msg.Type := CoherenceMessageType:PutML2;
                  out_msg.Sender := machineID;
                  out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__M_evict);
                DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                respfrom_in.dequeue(clockEdge());
                trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                //trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1) {
              tbe.acksReceivedL1 := tbe.acksReceivedL1+1;
              setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on respfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              respfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else {
            trigger(Event:Stallrespfrom_in, LineAddress, getEntry(LineAddress), tbe);
          }
        }
      }
    }
    
    in_port(reqfrom_in, CoherenceMessage, reqFrom, rank=2) {
      if (reqfrom_in.isReady(clockEdge())) {
        peek (reqfrom_in, CoherenceMessage, block_on="LineAddress") {
          Addr LineAddress := in_msg.LineAddress;
          TBE tbe := TBEs[LineAddress];
          State st := getState(tbe, getEntry(LineAddress), LineAddress);
          DPRINTF(RubySlicc, "reqfrom_in: %s %s %s (addr: %#x)\n", in_msg.Type, in_msg.Sender, st, LineAddress);
          // Start Evict handler
          if((st == State:I__C__I && in_msg.Type == CoherenceMessageType:GetML1) ||
                (st == State:I__C__I && in_msg.Type == CoherenceMessageType:GetSL1Ifetch) ||
                (st == State:I__C__I && in_msg.Type == CoherenceMessageType:GetSL1)) {
            if (is_invalid(getEntry(LineAddress)) && cache.cacheAvail(LineAddress) == false ) {
              Addr victim := cache.cacheProbe(in_msg.LineAddress);
              DPRINTF(RubySlicc, "Evicting %#x (%s) for %#x\n", victim, getState(TBEs[victim], getEntry(victim), victim), LineAddress);
              Addr LineAddress := victim;
              TBE tbe := TBEs[LineAddress];
              Entry entry := getEntry(LineAddress);
              State st := getState(tbe, entry, LineAddress);
              if (st == State:E__C__M) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                  out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).ownerL1 := machineID;
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store__C__M);
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else if (st == State:I__C__I) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (getEntry(LineAddress).ownerL1 == machineID) {
                    enqueue(reqto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                      out_msg.Type := CoherenceMessageType:PutIL2;
                      out_msg.Sender := machineID;
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__I_evict);
                  }
                }
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else if (st == State:I__C__M) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (getEntry(LineAddress).ownerL1 == machineID) {
                    enqueue(reqto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Data;
                      out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                      out_msg.Type := CoherenceMessageType:PutML2;
                      out_msg.Sender := machineID;
                      out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__M_evict);
                    trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else if (st == State:I__C__S) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                getEntry(LineAddress).ownerL1 := machineID;
                tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (getEntry(LineAddress).ownerL1 == machineID) {
                    enqueue(reqto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                      out_msg.Type := CoherenceMessageType:PutSL2;
                      out_msg.Sender := machineID;
                    }
                    setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__S_evict);
                    trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else if (st == State:M__C__M) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                  out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).ownerL1 := machineID;
                setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store__C__M);
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else if (st == State:S__C__M) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                if (getEntry(LineAddress).cacheL1.isElement(machineID)) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (getEntry(LineAddress).cacheL1.count() != 0) {
                    enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination := getEntry(LineAddress).cacheL1;
                      out_msg.Type := CoherenceMessageType:InvL1;
                      out_msg.Sender := machineID;
                    }
                    getEntry(LineAddress).ownerL1 := machineID;
                    tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                    getEntry(LineAddress).cacheL1.clear();
                    if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                      getEntry(LineAddress).cacheL1.remove(machineID);
                      if (getEntry(LineAddress).ownerL1 == machineID) {
                        enqueue(reqto_out, CoherenceMessage, responseLatency) {
                          out_msg.LineAddress := LineAddress;
                          out_msg.MessageSize := MessageSizeType:Data;
                          out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                          out_msg.Type := CoherenceMessageType:PutML2;
                          out_msg.Sender := machineID;
                          out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                        }
                        setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__M_evict);
                        trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                      }
                    }
                    else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                      setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetM_Ack_AD__C__M);
                    }
                  }
                }
                else if (getEntry(LineAddress).cacheL1.isElement(machineID) == false) {
                  if (getEntry(LineAddress).cacheL1.count() != 0) {
                    enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination := getEntry(LineAddress).cacheL1;
                      out_msg.Type := CoherenceMessageType:InvL1;
                      out_msg.Sender := machineID;
                    }
                    getEntry(LineAddress).ownerL1 := machineID;
                    tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                    getEntry(LineAddress).cacheL1.clear();
                    if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                      getEntry(LineAddress).cacheL1.remove(machineID);
                      if (getEntry(LineAddress).ownerL1 == machineID) {
                        enqueue(reqto_out, CoherenceMessage, responseLatency) {
                          out_msg.LineAddress := LineAddress;
                          out_msg.MessageSize := MessageSizeType:Data;
                          out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                          out_msg.Type := CoherenceMessageType:PutML2;
                          out_msg.Sender := machineID;
                          out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                        }
                        setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__M_evict);
                        trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                      }
                    }
                    else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                      setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetM_Ack_AD__C__M);
                    }
                  }
                }
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else if (st == State:S__C__S) {
                if (is_invalid(tbe)) {
                  if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                    trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                  } else {
                    DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                    reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                    trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                  }
                }
                tbe.acksReceivedL1 := 0;
                if (getEntry(LineAddress).cacheL1.isElement(machineID)) {
                  getEntry(LineAddress).cacheL1.remove(machineID);
                  if (getEntry(LineAddress).cacheL1.count() != 0) {
                    enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                      out_msg.LineAddress := LineAddress;
                      out_msg.MessageSize := MessageSizeType:Control;
                      out_msg.Destination := getEntry(LineAddress).cacheL1;
                      out_msg.Type := CoherenceMessageType:InvL1;
                      out_msg.Sender := machineID;
                    }
                    getEntry(LineAddress).ownerL1 := machineID;
                    tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                    getEntry(LineAddress).cacheL1.clear();
                    if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                      if (getEntry(LineAddress).ownerL1 == machineID) {
                        enqueue(reqto_out, CoherenceMessage, responseLatency) {
                          out_msg.LineAddress := LineAddress;
                          out_msg.MessageSize := MessageSizeType:Control;
                          out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                          out_msg.Type := CoherenceMessageType:PutSL2;
                          out_msg.Sender := machineID;
                        }
                        setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__S_evict);
                        trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                      }
                    }
                    else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                      setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetM_Ack_AD__C__S);
                    }
                  }
                }
                else if (getEntry(LineAddress).cacheL1.isElement(machineID) == false) {
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := machineID;
                  }
                  getEntry(LineAddress).ownerL1 := machineID;
                  tbe.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  getEntry(LineAddress).cacheL1.clear();
                  if (tbe.acksExpectedL1 == tbe.acksReceivedL1) {
                    if (getEntry(LineAddress).ownerL1 == machineID) {
                      enqueue(reqto_out, CoherenceMessage, responseLatency) {
                        out_msg.LineAddress := LineAddress;
                        out_msg.MessageSize := MessageSizeType:Control;
                        out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                        out_msg.Type := CoherenceMessageType:PutSL2;
                        out_msg.Sender := machineID;
                      }
                      setState(tbe, getEntry(LineAddress), LineAddress, State:evictI__C__S_evict);
                      trigger(Event:deallocevict, LineAddress, getEntry(LineAddress), tbe);
                    }
                  }
                  else if (tbe.acksExpectedL1 != tbe.acksReceivedL1) {
                    setState(tbe, getEntry(LineAddress), LineAddress, State:evictdM_x_pI_store_GetM_Ack_AD__C__S);
                  }
                }
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              } else {
                DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
              }
            }
          }
          // End Evict Handler
          if (st == State:E__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
              }
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1Ifetch) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetSL1;
                out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
              }
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).ownerL1);
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1E_GetS__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetSL1;
                out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
              }
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).ownerL1);
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1E_GetS__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (getEntry(LineAddress).ownerL1 == in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutE_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).ownerL1 != in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (getEntry(LineAddress).ownerL1 == in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutM_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).ownerL1 != in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (getEntry(LineAddress).ownerL1 == in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutE_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).ownerL1 != in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:I__C__I) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              if (is_invalid(getEntry(LineAddress))) {
                trigger(Event:allocCacheEntry, LineAddress, getEntry(LineAddress), tbe);
              }
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              enqueue(reqto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                out_msg.Type := CoherenceMessageType:GetML2;
                out_msg.Sender := machineID;
              }
              tbe.acksReceivedL2 := 0;
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__I_store);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              cache.setMRU(LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              if (is_invalid(getEntry(LineAddress))) {
                trigger(Event:allocCacheEntry, LineAddress, getEntry(LineAddress), tbe);
              }
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              enqueue(reqto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                out_msg.Type := CoherenceMessageType:GetSL2;
                //out_msg.Type := CoherenceMessageType:GetML2;
                out_msg.Sender := machineID;
              }
              tbe.acksReceivedL2 := 0;
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__I_store);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1Ifetch) {
              if (is_invalid(getEntry(LineAddress))) {
                trigger(Event:allocCacheEntry, LineAddress, getEntry(LineAddress), tbe);
              }
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              enqueue(reqto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                out_msg.Type := CoherenceMessageType:GetSL2Ifetch;
                out_msg.Sender := machineID;
              }
              tbe.acksReceivedL2 := 0;
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__I_load);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                //trigger(Event:deallocreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              //trigger(Event:deallocreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__I);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              //trigger(Event:deallocreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:I__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
              }
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1Ifetch) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetS_AckL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:E__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (getEntry(LineAddress).ownerL1 == in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutE_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).ownerL1 != in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (getEntry(LineAddress).cacheL1.count() == 0) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.count() != 0) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (getEntry(LineAddress).cacheL1.count() == 0) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.count() != 0) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:I__C__S) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              enqueue(reqto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                out_msg.Type := CoherenceMessageType:GetML2;
                out_msg.Sender := machineID;
              }
              tbe.acksReceivedL2 := 0;
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1I__C__S_store);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1Ifetch) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetS_AckL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetS_AckL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetML1) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              enqueue(reqto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                out_msg.Type := CoherenceMessageType:GetML2;
                out_msg.Sender := machineID;
              }
              tbe.acksReceivedL2 := 0;
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1I__C__S_store);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (getEntry(LineAddress).ownerL1 == in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutE_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).ownerL1 != in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (getEntry(LineAddress).cacheL1.count() == 0) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.count() != 0) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(in_msg.Sender);
                out_msg.Type := CoherenceMessageType:PutI_AckL1;
                out_msg.Sender := machineID;
              }
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (getEntry(LineAddress).cacheL1.count() == 0) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).cacheL1.count() != 0) {
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:M__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetML1;
                out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
              }
              getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1Ifetch) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetSL1;
                out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
              }
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).ownerL1);
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1M_GetS__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1);
                out_msg.Type := CoherenceMessageType:Fwd_GetSL1;
                out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
              }
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).ownerL1);
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetSL1M_GetS__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (getEntry(LineAddress).ownerL1 == in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutM_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).ownerL1 != in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (getEntry(LineAddress).ownerL1 == in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutM_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).ownerL1 != in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
              if (getEntry(LineAddress).ownerL1 == in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutM_AckL1;
                  out_msg.Sender := machineID;
                }
                setCacheBlock(tbe, getEntry(LineAddress), LineAddress, in_msg.cl);
                setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
              else if (getEntry(LineAddress).ownerL1 != in_msg.Sender) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                reqfrom_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
              }
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:S__C__S) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              if (is_invalid(tbe)) {
                if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                  trigger(Event:allocTBE, LineAddress, getEntry(LineAddress), tbe);
                } else {
                  DPRINTF(RubySlicc, "recycling %s on reqfrom_in (addr: %#x)\n", st, LineAddress);
                  reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
                  trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              enqueue(reqto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                out_msg.Type := CoherenceMessageType:GetML2;
                out_msg.Sender := machineID;
              }
              tbe.acksReceivedL2 := 0;
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:GetML1S__C__S_store);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1Ifetch) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetS_AckL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetS_AckL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__S);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else if (st == State:S__C__M) {
            if (in_msg.Type == CoherenceMessageType:GetML1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              if (getEntry(LineAddress).cacheL1.isElement(getEntry(LineAddress).proxy_msgL1_src)) {
                getEntry(LineAddress).cacheL1.remove(getEntry(LineAddress).proxy_msgL1_src);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                    out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  cache.setMRU(LineAddress);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                    out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  }
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  cache.setMRU(LineAddress);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(getEntry(LineAddress).proxy_msgL1_src) == false) {
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                    out_msg.Type := CoherenceMessageType:GetM_Ack_DL1;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  cache.setMRU(LineAddress);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  enqueue(respto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Data;
                    out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                    out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1;
                    out_msg.Sender := machineID;
                    out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
                    out_msg.acksExpectedL1 := getEntry(LineAddress).cacheL1.count();
                  }
                  enqueue(fwdto_out, CoherenceMessage, responseLatency) {
                    out_msg.LineAddress := LineAddress;
                    out_msg.MessageSize := MessageSizeType:Control;
                    out_msg.Destination := getEntry(LineAddress).cacheL1;
                    out_msg.Type := CoherenceMessageType:InvL1;
                    out_msg.Sender := getEntry(LineAddress).proxy_msgL1_src;
                  }
                  getEntry(LineAddress).ownerL1 := getEntry(LineAddress).proxy_msgL1_src;
                  getEntry(LineAddress).cacheL1.clear();
                  cache.setMRU(LineAddress);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                  setState(tbe, getEntry(LineAddress), LineAddress, State:M__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:GetSL1Ifetch) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetS_AckL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:GetSL1) {
              getEntry(LineAddress).proxy_msgL1_src := in_msg.Sender;
              enqueue(respto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).proxy_msgL1_src);
                out_msg.Type := CoherenceMessageType:GetS_AckL1;
                out_msg.Sender := machineID;
                out_msg.cl := getCacheBlock(tbe, getEntry(LineAddress), LineAddress);
              }
              getEntry(LineAddress).cacheL1.add(getEntry(LineAddress).proxy_msgL1_src);
              cache.setMRU(LineAddress);
              setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
              DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
              reqfrom_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
            } else if (in_msg.Type == CoherenceMessageType:PutEL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:PutML1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else if (in_msg.Type == CoherenceMessageType:PutSL1) {
              if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender)) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutS_AckL1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1.remove(in_msg.Sender);
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
              else if (getEntry(LineAddress).cacheL1.isElement(in_msg.Sender) == false) {
                enqueue(respto_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(in_msg.Sender);
                  out_msg.Type := CoherenceMessageType:PutI_AckL1;
                  out_msg.Sender := machineID;
                }
                if (getEntry(LineAddress).cacheL1.count() == 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:I__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
                else if (getEntry(LineAddress).cacheL1.count() != 0) {
                  setState(tbe, getEntry(LineAddress), LineAddress, State:S__C__M);
                  DPRINTF(RubySlicc, "Popping %s %s on reqfrom_in (addr: %#x)\n", in_msg.Type, in_msg.Sender, LineAddress);
                  reqfrom_in.dequeue(clockEdge());
                  trigger(Event:deallocTBE, LineAddress, getEntry(LineAddress), tbe);
                }
              }
            } else {
              trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
            }
          } else {
            trigger(Event:Stallreqfrom_in, LineAddress, getEntry(LineAddress), tbe);
          }
        }
      }
    }
    
    
    //Backend.SLICC.ModularSLICC.proxy.GenProxyActions
    action(allocEntry, "a", desc="Allocate an entry") {
      assert(is_invalid(cache_entry));
      assert(cache.cacheAvail(address));
      set_cache_entry(cache.allocate(address, new Entry));
    }
    action(deallocEntry, "d", desc="Deallocate an entry") {
      assert(is_valid(cache_entry));
      cache.deallocate(address);
      unset_cache_entry();
    }
    action(a_allocTBE, "aTBE", desc="Allocate TBE entry.") {
      DPRINTF(RubySlicc, "Allocating TBE for address: %#x\n", address);
      check_allocate(TBEs);
      DPRINTF(RubySlicc, "Check allocate passed for address: %#x\n", address);
      TBEs.allocate(address);
      DPRINTF(RubySlicc, "Allocated TBE for address: %#x\n", address);
      set_tbe(TBEs[address]);
      DPRINTF(RubySlicc, "Set TBE for address: %#x\n", address);
      tbe.dirty := false;
      tbe.acksExpectedL1 := 0;
      tbe.acksReceivedL1 := 0;
      tbe.acksExpectedL2 := 0;
      tbe.acksReceivedL2 := 0;
    }
    action(a_deallocTBE, "dTBE", desc="Deallocate TBE entry.") {
      DPRINTF(RubySlicc, "Deallocating TBE for address: %#x\n", address);
      if (is_valid(tbe)) {
      DPRINTF(RubySlicc, "Deallocated TBE for address: %#x\n", address);
        TBEs.deallocate(address);
        unset_tbe();
      }
    }
    action(a_copyEntryToTBE, "cpTBE", desc="Copy Entry to TBE.") {
      if (is_valid(cache_entry)) {
        if (is_valid(tbe)) {
          tbe.cl := cache_entry.cl;
          tbe.dirty := true;
        }
      }
    }
    action(popfwdfrom_in, "pfwdfrom_in0", desc="Pop the fwdfrom_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      fwdfrom_in.dequeue(clockEdge());
    }
    
    action(recyclefwdfrom_in, "rfwdfrom_in0", desc="Recycle the fwdfrom_in port") {
      DPRINTF(RubySlicc, "Stalling fwdfrom_in (addr: %#x)\n", address);
      fwdfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
      //stall_and_wait(fwdfrom_in, address);
    }
    
    action(popreqfrom_in, "preqfrom_in0", desc="Pop the reqfrom_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      reqfrom_in.dequeue(clockEdge());
    }
    
    action(recyclereqfrom_in, "rreqfrom_in0", desc="Recycle the reqfrom_in port") {
      DPRINTF(RubySlicc, "Stalling reqfrom_in (addr: %#x)\n", address);
      reqfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
      //stall_and_wait(reqfrom_in, address);
    }
    
    action(poprespfrom_in, "prespfrom_in0", desc="Pop the respfrom_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      respfrom_in.dequeue(clockEdge());
    }
    
    action(recyclerespfrom_in, "rrespfrom_in0", desc="Recycle the respfrom_in port") {
      DPRINTF(RubySlicc, "Stalling respfrom_in (addr: %#x)\n", address);
      respfrom_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
      //stall_and_wait(respfrom_in, address);
    }
    
    action(empty, "e", desc="Empty action") {
      // empty action; useful as SLICC requires valid transitions
      // to be non-empty, but the actions being invoked can still be empty
      // e.g. to simulate a z-stall
    }
    
    //Backend.SLICC.ModularSLICC.proxy.GenProxyTransitions
    transition({I__C__I}, deallocfwdfrom_in) {
      deallocEntry;
      a_deallocTBE;
      popfwdfrom_in;
    }
    
    transition({I__C__I}, deallocreqfrom_in) {
      deallocEntry;
      a_deallocTBE;
      popreqfrom_in;
    }
    
    transition({I__C__I}, deallocrespfrom_in) {
      deallocEntry;
      a_deallocTBE;
      poprespfrom_in;
    }
    
    transition({evictI__C__I_evict, evictI__C__S_evict, evictI__C__M_evict}, deallocevict) {
      a_copyEntryToTBE;
      deallocEntry;
    }
    
    transition({E__C__M, Fwd_GetML2dM_x_pI_store_GetM_Ack_AD__C__M, Fwd_GetML2dM_x_pI_store__C__M, Fwd_GetSL2dM_x_pI_store_GetM_Ack_AD__C__M, Fwd_GetSL2dM_x_pI_store__C__M, GetML1I__C__I_store, GetML1I__C__I_store_GetM_Ack_AD, GetML1I__C__S_store, GetML1I__C__S_store_GetM_Ack_AD, GetSL1E_GetS__C__M, GetSL1I__C__I_store, GetSL1I__C__I_store_GetM_Ack_AD, GetSL1I__C__S_store, GetSL1I__C__S_store_GetM_Ack_AD, GetSL1M_GetS__C__M, I__C__I, I__C__M, I__C__S, M__C__M, S__C__M, evictI__C__I_evict, evictI__C__M_evict, evictI__C__S_evict, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store__C__M, S__C__S, GetSL1I__C__I_load, InvL2dM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__S, GetML1S__C__S_store, GetML1S__C__I_store, GetML1S__C__S_store_GetM_Ack_AD, InvL2dM_x_pI_store_GetM_Ack_AD__C__S_store, GetML1S__C__I_store_GetM_Ack_AD}, Stallfwdfrom_in) {
      recyclefwdfrom_in;
    }
    
    transition({E__C__M, Fwd_GetML2dM_x_pI_store_GetM_Ack_AD__C__M, Fwd_GetML2dM_x_pI_store__C__M, Fwd_GetSL2dM_x_pI_store_GetM_Ack_AD__C__M, Fwd_GetSL2dM_x_pI_store__C__M, GetML1I__C__I_store, GetML1I__C__I_store_GetM_Ack_AD, GetML1I__C__S_store, GetML1I__C__S_store_GetM_Ack_AD, GetSL1E_GetS__C__M, GetSL1I__C__I_store, GetSL1I__C__I_store_GetM_Ack_AD, GetSL1I__C__S_store, GetSL1I__C__S_store_GetM_Ack_AD, GetSL1M_GetS__C__M, I__C__I, I__C__M, I__C__S, M__C__M, S__C__M, evictI__C__I_evict, evictI__C__M_evict, evictI__C__S_evict, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store__C__M, S__C__S, GetSL1I__C__I_load, InvL2dM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__S, GetML1S__C__S_store, GetML1S__C__I_store, GetML1S__C__S_store_GetM_Ack_AD, InvL2dM_x_pI_store_GetM_Ack_AD__C__S_store, GetML1S__C__I_store_GetM_Ack_AD}, Stallreqfrom_in) {
      recyclereqfrom_in;
    }
    
    transition({E__C__M, Fwd_GetML2dM_x_pI_store_GetM_Ack_AD__C__M, Fwd_GetML2dM_x_pI_store__C__M, Fwd_GetSL2dM_x_pI_store_GetM_Ack_AD__C__M, Fwd_GetSL2dM_x_pI_store__C__M, GetML1I__C__I_store, GetML1I__C__I_store_GetM_Ack_AD, GetML1I__C__S_store, GetML1I__C__S_store_GetM_Ack_AD, GetSL1E_GetS__C__M, GetSL1I__C__I_store, GetSL1I__C__I_store_GetM_Ack_AD, GetSL1I__C__S_store, GetSL1I__C__S_store_GetM_Ack_AD, GetSL1M_GetS__C__M, I__C__I, I__C__M, I__C__S, M__C__M, S__C__M, evictI__C__I_evict, evictI__C__M_evict, evictI__C__S_evict, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store__C__M, S__C__S, GetSL1I__C__I_load, InvL2dM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__S, GetML1S__C__S_store, GetML1S__C__I_store, GetML1S__C__S_store_GetM_Ack_AD, InvL2dM_x_pI_store_GetM_Ack_AD__C__S_store, GetML1S__C__I_store_GetM_Ack_AD}, Stallrespfrom_in) {
      recyclerespfrom_in;
    }
    
    transition({E__C__M, Fwd_GetML2dM_x_pI_store_GetM_Ack_AD__C__M, Fwd_GetML2dM_x_pI_store__C__M, Fwd_GetSL2dM_x_pI_store_GetM_Ack_AD__C__M, Fwd_GetSL2dM_x_pI_store__C__M, GetML1I__C__I_store, GetML1I__C__I_store_GetM_Ack_AD, GetML1I__C__S_store, GetML1I__C__S_store_GetM_Ack_AD, GetSL1E_GetS__C__M, GetSL1I__C__I_store, GetSL1I__C__I_store_GetM_Ack_AD, GetSL1I__C__S_store, GetSL1I__C__S_store_GetM_Ack_AD, GetSL1M_GetS__C__M, I__C__I, I__C__M, I__C__S, M__C__M, S__C__M, evictI__C__I_evict, evictI__C__M_evict, evictI__C__S_evict, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store__C__M, S__C__S, GetSL1I__C__I_load, InvL2dM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__S, GetML1S__C__S_store, GetML1S__C__I_store, GetML1S__C__S_store_GetM_Ack_AD, InvL2dM_x_pI_store_GetM_Ack_AD__C__S_store, GetML1S__C__I_store_GetM_Ack_AD}, allocCacheEntry) {
      allocEntry;
    }
    
    transition({E__C__M, Fwd_GetML2dM_x_pI_store_GetM_Ack_AD__C__M, Fwd_GetML2dM_x_pI_store__C__M, Fwd_GetSL2dM_x_pI_store_GetM_Ack_AD__C__M, Fwd_GetSL2dM_x_pI_store__C__M, GetML1I__C__I_store, GetML1I__C__I_store_GetM_Ack_AD, GetML1I__C__S_store, GetML1I__C__S_store_GetM_Ack_AD, GetSL1E_GetS__C__M, GetSL1I__C__I_store, GetSL1I__C__I_store_GetM_Ack_AD, GetSL1I__C__S_store, GetSL1I__C__S_store_GetM_Ack_AD, GetSL1M_GetS__C__M, I__C__I, I__C__M, I__C__S, M__C__M, S__C__M, evictI__C__I_evict, evictI__C__M_evict, evictI__C__S_evict, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store__C__M, S__C__S, GetSL1I__C__I_load, InvL2dM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__S, GetML1S__C__S_store, GetML1S__C__I_store, GetML1S__C__S_store_GetM_Ack_AD, InvL2dM_x_pI_store_GetM_Ack_AD__C__S_store, GetML1S__C__I_store_GetM_Ack_AD}, allocTBE) {
      a_allocTBE;
    }
    
    transition({E__C__M, Fwd_GetML2dM_x_pI_store_GetM_Ack_AD__C__M, Fwd_GetML2dM_x_pI_store__C__M, Fwd_GetSL2dM_x_pI_store_GetM_Ack_AD__C__M, Fwd_GetSL2dM_x_pI_store__C__M, GetML1I__C__I_store, GetML1I__C__I_store_GetM_Ack_AD, GetML1I__C__S_store, GetML1I__C__S_store_GetM_Ack_AD, GetSL1E_GetS__C__M, GetSL1I__C__I_store, GetSL1I__C__I_store_GetM_Ack_AD, GetSL1I__C__S_store, GetSL1I__C__S_store_GetM_Ack_AD, GetSL1M_GetS__C__M, I__C__I, I__C__M, I__C__S, M__C__M, S__C__M, evictI__C__I_evict, evictI__C__M_evict, evictI__C__S_evict, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store__C__M, S__C__S, GetSL1I__C__I_load, InvL2dM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__S, GetML1S__C__S_store, GetML1S__C__I_store, GetML1S__C__S_store_GetM_Ack_AD, InvL2dM_x_pI_store_GetM_Ack_AD__C__S_store, GetML1S__C__I_store_GetM_Ack_AD}, deallocTBE) {
      a_deallocTBE;
    }
    
    transition({E__C__M, Fwd_GetML2dM_x_pI_store_GetM_Ack_AD__C__M, Fwd_GetML2dM_x_pI_store__C__M, Fwd_GetSL2dM_x_pI_store_GetM_Ack_AD__C__M, Fwd_GetSL2dM_x_pI_store__C__M, GetML1I__C__I_store, GetML1I__C__I_store_GetM_Ack_AD, GetML1I__C__S_store, GetML1I__C__S_store_GetM_Ack_AD, GetSL1E_GetS__C__M, GetSL1I__C__I_store, GetSL1I__C__I_store_GetM_Ack_AD, GetSL1I__C__S_store, GetSL1I__C__S_store_GetM_Ack_AD, GetSL1M_GetS__C__M, I__C__I, I__C__M, I__C__S, M__C__M, S__C__M, evictI__C__I_evict, evictI__C__M_evict, evictI__C__S_evict, evictdM_x_pI_store_GetM_Ack_AD__C__M, evictdM_x_pI_store__C__M, S__C__S, GetSL1I__C__I_load, InvL2dM_x_pI_store_GetM_Ack_AD__C__S, evictdM_x_pI_store_GetM_Ack_AD__C__S, GetML1S__C__S_store, GetML1S__C__I_store, GetML1S__C__S_store_GetM_Ack_AD, InvL2dM_x_pI_store_GetM_Ack_AD__C__S_store, GetML1S__C__I_store_GetM_Ack_AD}, Progress) {
      empty;
    }
}
// EOF<proxy>